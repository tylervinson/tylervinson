<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON-LD Schema Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: #fafafa;
            color: #1a1a1a;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            background: #ffffff;
            padding: 2rem;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 2rem;
            font-weight: 300;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: #666;
            font-size: 0.95rem;
        }

        .upload-section {
            background: #ffffff;
            padding: 2rem;
            border: 1px solid #e0e0e0;
            margin-bottom: 2rem;
        }

        .upload-zone {
            border: 2px dashed #ccc;
            padding: 3rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fafafa;
        }

        .upload-zone:hover {
            border-color: #999;
            background: #f5f5f5;
        }

        .upload-zone.dragover {
            border-color: #0066cc;
            background: #f0f7ff;
        }

        input[type="file"] {
            display: none;
        }

        button {
            background: #1a1a1a;
            color: #ffffff;
            border: none;
            padding: 0.75rem 2rem;
            font-size: 0.95rem;
            cursor: pointer;
            transition: background 0.2s;
            font-family: inherit;
        }

        button:hover:not(:disabled) {
            background: #333;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .progress-section {
            background: #ffffff;
            padding: 2rem;
            border: 1px solid #e0e0e0;
            margin-bottom: 2rem;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            margin: 1rem 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #1a1a1a;
            width: 0%;
            transition: width 0.3s;
        }

        .status {
            color: #666;
            font-size: 0.9rem;
            margin-top: 1rem;
        }

        .results-section {
            background: #ffffff;
            padding: 2rem;
            border: 1px solid #e0e0e0;
            display: none;
        }

        .result-item {
            padding: 1rem;
            border-bottom: 1px solid #f0f0f0;
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 1rem;
            align-items: center;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-url {
            font-size: 0.9rem;
            color: #666;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .result-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }

        .download-all {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #e0e0e0;
        }

        .info-box {
            background: #f9f9f9;
            padding: 1rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            color: #666;
            border-left: 3px solid #1a1a1a;
        }

        .warning-box {
            background: #fff3cd;
            padding: 1rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            color: #856404;
            border-left: 3px solid #ffc107;
        }

        pre {
            background: #f5f5f5;
            padding: 1rem;
            overflow-x: auto;
            font-size: 0.85rem;
            border: 1px solid #e0e0e0;
        }

        .schema-preview {
            display: none;
            margin-top: 1rem;
        }

        .html-preview {
            display: none;
            margin-top: 1rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
        }

        .cors-note {
            background: #e3f2fd;
            padding: 1rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            color: #1565c0;
            border-left: 3px solid #2196f3;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>JSON-LD Schema Generator</h1>
            <p class="subtitle">Upload URLs and automatically scrape page content to generate comprehensive schemas</p>
        </div>
    </header>

    <div class="container">
        <div class="upload-section">
            <h2 style="margin-bottom: 1rem; font-weight: 400;">Upload Spreadsheet</h2>
            <div class="cors-note">
                <strong>✓ CORS Proxy Enabled:</strong> This tool uses corsproxy.io to fetch pages from any domain. It will automatically scrape each URL to extract page metadata (title, description, organization info, phone numbers, etc.) and generate comprehensive JSON-LD schemas.
            </div>
            <div class="info-box">
                <strong>Supported formats:</strong> CSV, XLSX, XLS<br>
                <strong>Required:</strong> Just a "URL" column - everything else is automatically extracted!<br>
                <strong>Extracted automatically:</strong> Page title, meta description, organization name, phone numbers, breadcrumbs, and more
            </div>
            
            <div class="upload-zone" id="uploadZone">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="1.5" style="margin-bottom: 1rem;">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="17 8 12 3 7 8"></polyline>
                    <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
                <p style="color: #666; margin-bottom: 0.5rem;">Drop your spreadsheet here or click to browse</p>
                <p style="color: #999; font-size: 0.85rem;">CSV, XLSX, or XLS files</p>
                <input type="file" id="fileInput" accept=".csv,.xlsx,.xls">
            </div>

            <div style="margin-top: 1.5rem;">
                <button id="generateBtn" disabled>Generate Schemas</button>
            </div>
        </div>

        <div class="progress-section" id="progressSection">
            <h2 style="margin-bottom: 1rem; font-weight: 400;">Scraping Pages & Generating Schemas...</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="status" id="statusText">Preparing...</div>
        </div>

        <div class="results-section" id="resultsSection">
            <h2 style="margin-bottom: 1.5rem; font-weight: 400;">Generated Schemas</h2>
            <div id="resultsList"></div>
            <div class="download-all">
                <button id="downloadAllBtn">Download All Schemas (ZIP)</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        let uploadedData = [];
        let generatedSchemas = [];
        let siteConfig = null; // Will be extracted from first page

        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const generateBtn = document.getElementById('generateBtn');

        uploadZone.addEventListener('click', () => fileInput.click());

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFile(file);
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        function handleFile(file) {
            const reader = new FileReader();
            
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                    
                    if (jsonData.length === 0) {
                        alert('The spreadsheet appears to be empty');
                        return;
                    }

                    const firstRow = jsonData[0];
                    const urlKey = Object.keys(firstRow).find(key => 
                        key.toLowerCase() === 'url' || key.toLowerCase() === 'urls'
                    );

                    if (!urlKey) {
                        alert('Could not find a "URL" column in your spreadsheet.');
                        return;
                    }

                    uploadedData = jsonData.map(row => ({
                        url: row[urlKey]
                    })).filter(row => row.url);

                    generateBtn.disabled = false;
                    uploadZone.querySelector('p').textContent = `✓ Loaded ${uploadedData.length} URLs`;
                    uploadZone.querySelector('p').style.color = '#2e7d32';
                } catch (error) {
                    console.error('Error parsing file:', error);
                    alert('Error parsing file. Please ensure it\'s a valid CSV or Excel file.');
                }
            };

            reader.readAsArrayBuffer(file);
        }

        generateBtn.addEventListener('click', async () => {
            if (uploadedData.length === 0) return;

            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';
            generateBtn.disabled = true;

            generatedSchemas = [];
            const total = uploadedData.length;

            for (let i = 0; i < uploadedData.length; i++) {
                const item = uploadedData[i];
                updateProgress(i + 1, total, `Scraping ${item.url}`);

                try {
                    // Scrape the page
                    const pageData = await scrapePage(item.url);
                    
                    // Extract site config from first page
                    if (i === 0) {
                        siteConfig = extractSiteConfig(pageData);
                    }
                    
                    // Generate schema
                    const schema = generateSchemaFromPageData(pageData, siteConfig);
                    generatedSchemas.push({
                        url: item.url,
                        schema: JSON.stringify(schema, null, 2),
                        success: true
                    });
                } catch (error) {
                    console.error(`Error processing ${item.url}:`, error);
                    generatedSchemas.push({
                        url: item.url,
                        error: error.message,
                        success: false
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 100));
            }

            displayResults();
            document.getElementById('progressSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';
            generateBtn.disabled = false;
        });

        async function scrapePage(url) {
            // Use CORS proxy to fetch the page
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
            
            try {
                const response = await fetch(proxyUrl);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                return {
                    url: url,
                    doc: doc,
                    html: html
                };
            } catch (error) {
                throw new Error(`Failed to fetch: ${error.message}`);
            }
        }

        function extractSiteConfig(pageData) {
            const doc = pageData.doc;
            const url = new URL(pageData.url);
            
            // Extract organization info from page
            const config = {
                websiteUrl: url.origin,
                orgName: null,
                orgShortName: null,
                logoUrl: null,
                phones: {
                    sales: null,
                    service: null,
                    tty: null
                },
                areaServed: 'US'
            };

            // Try to find organization name from meta tags or content
            const ogSiteName = doc.querySelector('meta[property="og:site_name"]');
            if (ogSiteName) {
                config.orgShortName = ogSiteName.content;
            }

            // Try to find from title
            const title = doc.querySelector('title');
            if (title && title.textContent.includes('|')) {
                const parts = title.textContent.split('|');
                config.orgShortName = parts[parts.length - 1].trim();
            }

            // Find logo
            const logo = doc.querySelector('meta[property="og:image"]') || 
                        doc.querySelector('link[rel="icon"]') ||
                        doc.querySelector('img[class*="logo"]');
            if (logo) {
                config.logoUrl = logo.content || logo.href || logo.src;
                if (config.logoUrl && !config.logoUrl.startsWith('http')) {
                    config.logoUrl = url.origin + config.logoUrl;
                }
            }

            // Find phone numbers in page content
            const bodyText = doc.body.textContent;
            const phoneRegex = /(\+?1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/g;
            const phones = bodyText.match(phoneRegex);
            if (phones && phones.length > 0) {
                config.phones.service = phones[0].replace(/\s+/g, '-');
            }

            // Check for TTY
            if (bodyText.includes('TTY') || bodyText.includes('711')) {
                config.phones.tty = '711';
            }

            return config;
        }

        function generateSchemaFromPageData(pageData, siteConfig) {
            const doc = pageData.doc;
            const url = new URL(pageData.url);
            const path = url.pathname;
            const segments = path.split('/').filter(s => s);

            // Extract page metadata
            const title = doc.querySelector('title')?.textContent || 
                         doc.querySelector('meta[property="og:title"]')?.content ||
                         doc.querySelector('h1')?.textContent;
            
            const description = doc.querySelector('meta[name="description"]')?.content ||
                               doc.querySelector('meta[property="og:description"]')?.content;

            const pageType = determinePageType(path, doc);

            // Build comprehensive schema
            const schema = {
                "@context": "https://schema.org",
                "@type": pageType,
                "@id": `${pageData.url}#webpage`,
                "url": pageData.url,
                "name": title || 'Page',
                "inLanguage": "en"
            };

            if (description) {
                schema.description = description;
            }

            // Add isPartOf
            schema.isPartOf = {
                "@type": "WebSite",
                "name": siteConfig.orgShortName || extractDomainName(url.hostname),
                "url": siteConfig.websiteUrl + "/"
            };

            // Add primary image
            if (siteConfig.logoUrl) {
                schema.primaryImageOfPage = {
                    "@type": "ImageObject",
                    "url": siteConfig.logoUrl
                };
            }

            // Build breadcrumbs from URL path
            if (segments.length > 0) {
                schema.breadcrumb = {
                    "@type": "BreadcrumbList",
                    "itemListElement": []
                };

                let currentPath = '';
                segments.forEach((segment, index) => {
                    currentPath += '/' + segment;
                    schema.breadcrumb.itemListElement.push({
                        "@type": "ListItem",
                        "position": index + 1,
                        "name": segment.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                        "item": `${url.origin}${currentPath}`
                    });
                });
            }

            // Build publisher
            schema.publisher = {
                "@type": "Organization",
                "@id": `${siteConfig.websiteUrl}/#organization`,
                "name": siteConfig.orgName || siteConfig.orgShortName || extractDomainName(url.hostname),
                "url": siteConfig.websiteUrl + "/"
            };

            if (siteConfig.logoUrl) {
                schema.publisher.logo = {
                    "@type": "ImageObject",
                    "url": siteConfig.logoUrl
                };
            }

            // Add contact points
            const contactPoints = [];
            if (siteConfig.phones.sales) {
                contactPoints.push({
                    "@type": "ContactPoint",
                    "telephone": siteConfig.phones.sales,
                    "contactType": "sales",
                    "areaServed": [siteConfig.areaServed],
                    "availableLanguage": ["en"]
                });
            }
            if (siteConfig.phones.service) {
                contactPoints.push({
                    "@type": "ContactPoint",
                    "telephone": siteConfig.phones.service,
                    "contactType": "customer service",
                    "areaServed": [siteConfig.areaServed],
                    "availableLanguage": ["en"]
                });
            }
            if (siteConfig.phones.tty) {
                contactPoints.push({
                    "@type": "ContactPoint",
                    "telephone": siteConfig.phones.tty,
                    "contactType": "TTY",
                    "areaServed": [siteConfig.areaServed],
                    "availableLanguage": ["en"]
                });
            }
            if (contactPoints.length > 0) {
                schema.publisher.contactPoint = contactPoints;
            }

            // Extract service/product information from page content
            const mainHeading = doc.querySelector('h1')?.textContent;
            const subheadings = Array.from(doc.querySelectorAll('h2, h3')).map(h => h.textContent.trim());
            const paragraphs = Array.from(doc.querySelectorAll('p')).slice(0, 5).map(p => p.textContent.trim());
            
            // Look for service indicators (plans, products, services mentioned)
            const bodyText = doc.body.textContent.toLowerCase();
            const hasServices = bodyText.includes('plan') || bodyText.includes('service') || 
                               bodyText.includes('product') || bodyText.includes('coverage') ||
                               bodyText.includes('benefit');
            
            if (hasServices && (path.includes('medicare') || path.includes('insurance') || 
                path.includes('plan') || path.includes('service'))) {
                
                // Create About section for services
                schema.about = {
                    "@type": "Service",
                    "name": mainHeading || title,
                    "provider": {
                        "@type": "Organization",
                        "@id": `${siteConfig.websiteUrl}/#organization`
                    },
                    "serviceType": extractServiceType(mainHeading, bodyText),
                    "description": description || (paragraphs[0] || '').substring(0, 200)
                };

                // Try to find target audience
                const audienceMatch = bodyText.match(/(medicare[- ]eligible|seniors|individuals|families|businesses)/i);
                if (audienceMatch) {
                    schema.about.audience = {
                        "@type": "PeopleAudience",
                        "name": audienceMatch[0].charAt(0).toUpperCase() + audienceMatch[0].slice(1)
                    };
                }

                // Try to extract area served from content
                const countyMatch = bodyText.match(/([A-Z][a-z]+\s+County)/g);
                if (countyMatch && countyMatch.length > 0) {
                    schema.about.areaServed = countyMatch.slice(0, 3).map(county => ({
                        "@type": "AdministrativeArea",
                        "name": county
                    }));
                }

                // Look for specific plan/product mentions
                const planNames = extractPlanNames(doc);
                if (planNames.length > 0) {
                    schema.about.hasOfferCatalog = {
                        "@type": "OfferCatalog",
                        "name": `${mainHeading || title} Plans`,
                        "itemListElement": {
                            "@type": "ItemList",
                            "numberOfItems": planNames.length,
                            "itemListElement": planNames.map((planName, idx) => ({
                                "@type": "Service",
                                "name": planName,
                                "description": `${planName} coverage option`
                            }))
                        }
                    };
                }
            }

            // Create mainEntity if we have service offerings
            if (schema.about && schema.about.hasOfferCatalog) {
                const plans = schema.about.hasOfferCatalog.itemListElement.itemListElement;
                schema.mainEntity = {
                    "@type": "ItemList",
                    "name": `Featured ${mainHeading || 'Plans'}`,
                    "itemListElement": plans.map((plan, idx) => ({
                        "@type": "ListItem",
                        "position": idx + 1,
                        "item": {
                            "@type": "Service",
                            "name": plan.name,
                            "url": pageData.url,
                            "provider": { "@id": `${siteConfig.websiteUrl}/#organization` }
                        }
                    }))
                };
            }

            // Add type-specific properties
            if (pageType === 'Article') {
                schema.author = {
                    "@type": "Organization",
                    "@id": `${siteConfig.websiteUrl}/#organization`
                };
                schema.headline = title;
                const datePublished = doc.querySelector('meta[property="article:published_time"]')?.content ||
                                     doc.querySelector('time[datetime]')?.getAttribute('datetime');
                if (datePublished) {
                    schema.datePublished = datePublished.split('T')[0];
                    schema.dateModified = datePublished.split('T')[0];
                }
            }

            // Add potential actions
            schema.potentialAction = [
                {
                    "@type": "SearchAction",
                    "target": {
                        "@type": "EntryPoint",
                        "urlTemplate": pageData.url
                    },
                    "query-input": "required name=search_term_string"
                }
            ];

            // Add additional action if CTA buttons found
            const ctaButtons = doc.querySelectorAll('a[href*="shop"], a[href*="enroll"], button');
            if (ctaButtons.length > 0) {
                const ctaText = Array.from(ctaButtons).find(btn => 
                    btn.textContent.toLowerCase().includes('shop') || 
                    btn.textContent.toLowerCase().includes('enroll') ||
                    btn.textContent.toLowerCase().includes('compare')
                );
                if (ctaText) {
                    schema.potentialAction.push({
                        "@type": "Action",
                        "name": ctaText.textContent.trim(),
                        "target": pageData.url
                    });
                }
            }

            return schema;
        }

        function extractServiceType(heading, bodyText) {
            if (bodyText.includes('medicare advantage') || bodyText.includes('hmo')) {
                return 'Medicare Advantage (Part C) HMO';
            }
            if (bodyText.includes('medicare')) {
                return 'Medicare Insurance';
            }
            if (bodyText.includes('health insurance')) {
                return 'Health Insurance';
            }
            return heading || 'Insurance Services';
        }

        function extractPlanNames(doc) {
            const planNames = [];
            
            // Look for common plan name patterns
            const headings = doc.querySelectorAll('h2, h3, h4');
            headings.forEach(h => {
                const text = h.textContent.trim();
                // Match patterns like "Blue Best Life", "Plan Name (HMO)", etc.
                if (text.match(/(Plan|Plus|Classic|Premium|Basic|Standard|Elite|Select)/i) ||
                    text.match(/\(HMO\)|\(PPO\)|\(EPO\)/)) {
                    planNames.push(text);
                }
            });

            // Look in lists
            const listItems = doc.querySelectorAll('li');
            listItems.forEach(li => {
                const text = li.textContent.trim();
                if (text.length < 100 && text.match(/(Plan|Plus|Classic|Premium|HMO|PPO)/i)) {
                    planNames.push(text);
                }
            });

            // Deduplicate and limit
            return [...new Set(planNames)].slice(0, 5);
        }

        function determinePageType(path, doc) {
            if (path.includes('/blog/') || path.includes('/article/') || path.includes('/news/')) {
                return 'Article';
            }
            if (path.includes('/product/') || path.includes('/shop/')) {
                return 'Product';
            }
            if (path.includes('/faq')) {
                return 'FAQPage';
            }
            if (path.includes('/contact')) {
                return 'ContactPage';
            }
            if (path.includes('/about')) {
                return 'AboutPage';
            }
            return 'WebPage';
        }

        function extractDomainName(hostname) {
            const parts = hostname.replace('www.', '').split('.');
            return parts[0].charAt(0).toUpperCase() + parts[0].slice(1);
        }

        function updateProgress(current, total, status) {
            const percent = (current / total) * 100;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('statusText').textContent = `${status} (${current}/${total})`;
        }

        function displayResults() {
            const resultsList = document.getElementById('resultsList');
            resultsList.innerHTML = '';

            generatedSchemas.forEach((result, index) => {
                const item = document.createElement('div');
                item.className = 'result-item';
                
                const urlDiv = document.createElement('div');
                urlDiv.innerHTML = `
                    <div class="result-url">${result.url}</div>
                    ${result.success ? '<span style="color: #2e7d32; font-size: 0.85rem;">✓ Generated</span>' : '<span style="color: #d32f2f; font-size: 0.85rem;">✗ ' + result.error + '</span>'}
                `;

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'result-actions';

                if (result.success) {
                    const viewBtn = document.createElement('button');
                    viewBtn.textContent = 'View JSON';
                    viewBtn.className = 'btn-small';
                    viewBtn.onclick = () => togglePreview(index);

                    const viewHtmlBtn = document.createElement('button');
                    viewHtmlBtn.textContent = 'View HTML';
                    viewHtmlBtn.className = 'btn-small';
                    viewHtmlBtn.onclick = () => toggleHtmlPreview(index);

                    const copyBtn = document.createElement('button');
                    copyBtn.textContent = 'Copy';
                    copyBtn.className = 'btn-small';
                    copyBtn.onclick = () => {
                        navigator.clipboard.writeText(result.schema);
                        copyBtn.textContent = 'Copied!';
                        setTimeout(() => copyBtn.textContent = 'Copy', 2000);
                    };

                    const downloadBtn = document.createElement('button');
                    downloadBtn.textContent = 'Download';
                    downloadBtn.className = 'btn-small';
                    downloadBtn.onclick = () => downloadSchema(result, index);

                    actionsDiv.appendChild(viewBtn);
                    actionsDiv.appendChild(viewHtmlBtn);
                    actionsDiv.appendChild(copyBtn);
                    actionsDiv.appendChild(downloadBtn);
                }

                item.appendChild(urlDiv);
                item.appendChild(actionsDiv);
                resultsList.appendChild(item);

                if (result.success) {
                    const preview = document.createElement('div');
                    preview.className = 'schema-preview';
                    preview.id = `preview-${index}`;
                    preview.innerHTML = `<pre>${escapeHtml(result.schema)}</pre>`;
                    item.appendChild(preview);

                    const htmlPreview = document.createElement('div');
                    htmlPreview.className = 'html-preview';
                    htmlPreview.id = `html-preview-${index}`;
                    item.appendChild(htmlPreview);
                }
            });
        }

        function togglePreview(index) {
            const preview = document.getElementById(`preview-${index}`);
            preview.style.display = preview.style.display === 'none' || !preview.style.display ? 'block' : 'none';
        }

        function toggleHtmlPreview(index) {
            const htmlPreview = document.getElementById(`html-preview-${index}`);
            const isVisible = htmlPreview.style.display === 'block';
            
            if (!isVisible) {
                const schema = generatedSchemas[index].schema;
                const htmlContent = generateHTMLFromSchema(schema);
                htmlPreview.innerHTML = htmlContent;
                htmlPreview.style.display = 'block';
            } else {
                htmlPreview.style.display = 'none';
            }
        }

        function generateHTMLFromSchema(schemaJson) {
            const schema = JSON.parse(schemaJson);
            
            let html = '<div style="font-family: -apple-system, BlinkMacSystemFont, \'Segoe UI\', sans-serif;">';
            html += '<h3 style="margin: 0 0 1rem 0; font-weight: 400;">' + escapeHtml(schema.name) + '</h3>';
            
            if (schema.description) {
                html += '<p style="color: #666; margin-bottom: 1.5rem;">' + escapeHtml(schema.description) + '</p>';
            }

            html += '<div style="background: #f9f9f9; padding: 1rem; margin-bottom: 1rem; border-left: 3px solid #1a1a1a;">';
            html += '<strong>Type:</strong> ' + escapeHtml(schema['@type']);
            html += ' | <strong>Language:</strong> ' + escapeHtml(schema.inLanguage);
            html += '</div>';

            if (schema.breadcrumb) {
                html += '<div style="margin-bottom: 1rem;"><strong>Breadcrumbs:</strong> ';
                schema.breadcrumb.itemListElement.forEach((item, idx) => {
                    if (idx > 0) html += ' / ';
                    html += escapeHtml(item.name);
                });
                html += '</div>';
            }

            if (schema.publisher) {
                html += '<div style="background: #fafafa; padding: 1rem; margin-bottom: 1rem; border: 1px solid #e0e0e0;">';
                html += '<strong>Publisher:</strong> ' + escapeHtml(schema.publisher.name);
                if (schema.publisher.contactPoint) {
                    html += '<div style="margin-top: 0.5rem;">';
                    schema.publisher.contactPoint.forEach(cp => {
                        html += '<div>' + escapeHtml(cp.contactType) + ': ' + escapeHtml(cp.telephone) + '</div>';
                    });
                    html += '</div>';
                }
                html += '</div>';
            }

            if (schema.about) {
                html += '<div style="background: #f0f7ff; padding: 1rem; margin-bottom: 1rem; border: 1px solid #2196f3;">';
                html += '<strong>About:</strong> ' + escapeHtml(schema.about.name || schema.about['@type']);
                if (schema.about.description) {
                    html += '<div style="margin-top: 0.5rem; color: #666;">' + escapeHtml(schema.about.description) + '</div>';
                }
                html += '</div>';
            }

            if (schema.mainEntity) {
                html += '<div style="background: #f0f7ff; padding: 1rem; margin-bottom: 1rem; border: 1px solid #2196f3;">';
                html += '<strong>Main Entity:</strong> ' + escapeHtml(schema.mainEntity.name || schema.mainEntity['@type']);
                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        function downloadSchema(result, index) {
            const blob = new Blob([result.schema], { type: 'application/json' });
            const filename = `schema-${index + 1}.json`;
            saveAs(blob, filename);
        }

        document.getElementById('downloadAllBtn').addEventListener('click', async () => {
            const zip = new JSZip();
            
            generatedSchemas.forEach((result, index) => {
                if (result.success) {
                    zip.file(`schema-${index + 1}.json`, result.schema);
                }
            });

            const content = await zip.generateAsync({ type: 'blob' });
            saveAs(content, 'schemas.zip');
        });

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>