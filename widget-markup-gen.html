<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sitecore Widget Editor - Code Generator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: #fafafa;
      color: #1a1a1a;
      line-height: 1.5;
      padding: 40px 20px;
    }

    .container { max-width: 1400px; margin: 0 auto; }

    header { margin-bottom: 40px; }

    h1 {
      font-size: 32px;
      font-weight: 400;
      margin-bottom: 8px;
      letter-spacing: -0.5px;
    }

    .subtitle {
      color: #666;
      font-size: 15px;
      font-weight: 400;
      margin-bottom: 24px;
    }

    .tab-nav {
      display: flex;
      border-bottom: 1px solid #e0e0e0;
      margin-top: 24px;
    }

    .tab-nav-link {
      padding: 12px 20px;
      text-decoration: none;
      color: #999;
      font-size: 12px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 2px solid transparent;
    }

    .tab-nav-link:hover { color: #666; }
    .tab-nav-link.active { color: #1a1a1a; border-bottom-color: #1a1a1a; }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .panel {
      background: #fff;
      padding: 30px;
      border: 1px solid #e0e0e0;
    }

    .panel-title {
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 24px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #666;
    }

    .form-group { margin-bottom: 20px; }

    label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 6px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    input[type="text"], textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #d0d0d0;
      background: #fff;
      font-family: inherit;
      font-size: 14px;
    }

    input[type="text"]:focus, textarea:focus {
      outline: none;
      border-color: #1a1a1a;
    }

    textarea {
      font-family: 'Courier New', monospace;
      resize: vertical;
      min-height: 200px;
    }

    /* ZIP Upload Zone */
    .upload-zone {
      border: 1px dashed #ccc;
      padding: 24px;
      text-align: center;
      cursor: pointer;
      margin-bottom: 20px;
      position: relative;
    }

    .upload-zone:hover { border-color: #1a1a1a; }

    .upload-zone.has-file {
      border-style: solid;
      border-color: #1a1a1a;
      background: #f9f9f9;
    }

    .upload-zone input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
      width: 100%;
      height: 100%;
    }

    .upload-icon { font-size: 24px; margin-bottom: 8px; }

    .upload-label {
      font-size: 13px;
      color: #666;
    }

    .upload-label strong { color: #1a1a1a; }

    .upload-status {
      font-size: 12px;
      margin-top: 8px;
      color: #666;
    }

    .upload-status.loaded { color: #2a7a2a; }
    .upload-status.error { color: #c00; }

    /* Widget list */
    .widget-list {
      margin-bottom: 16px;
    }

    .widget-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #f5f5f5;
      border: 1px solid #e0e0e0;
      margin-bottom: 4px;
      font-size: 13px;
    }

    .widget-item-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .widget-item-name { 
      font-family: 'Courier New', monospace;
      font-size: 13px;
    }
    
    .widget-item-badge {
      font-size: 11px;
      color: #999;
    }

    .widget-item-delete {
      background: #c00;
      color: #fff;
      border: none;
      padding: 6px 12px;
      font-size: 11px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .widget-item-delete:hover {
      background: #a00;
    }

    .info-box {
      background: #f5f5f5;
      border-left: 2px solid #1a1a1a;
      padding: 10px 12px;
      margin-top: 8px;
      font-size: 12px;
      color: #666;
    }

    button {
      background: #1a1a1a;
      color: #fff;
      border: none;
      padding: 12px 24px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    button:hover { background: #333; }
    button:disabled { background: #ccc; cursor: not-allowed; }

    .download-btn {
      width: 100%;
      padding: 16px;
      font-size: 14px;
      margin-bottom: 8px;
    }

    .download-info {
      font-size: 12px;
      color: #666;
      text-align: center;
      margin-bottom: 24px;
    }

    .analysis-box {
      background: #f9f9f9;
      border: 1px solid #e0e0e0;
      padding: 16px;
      margin: 20px 0;
    }

    .analysis-title {
      font-size: 11px;
      font-weight: 500;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 10px;
    }

    .analysis-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }

    .analysis-row:last-child { border-bottom: none; }
    .analysis-key { color: #666; }
    .analysis-val { font-family: 'Courier New', monospace; font-size: 12px; }

    .error-msg {
      border-left: 2px solid #c00;
      padding: 10px 12px;
      margin: 16px 0;
      font-size: 13px;
      color: #c00;
      background: #fff;
    }

    .success-msg {
      border-left: 2px solid #2a7a2a;
      padding: 10px 12px;
      margin: 16px 0;
      font-size: 13px;
      color: #2a7a2a;
      background: #fff;
    }

    .code-wrapper { position: relative; margin-top: 16px; }

    pre {
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 20px;
      padding-top: 50px;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.5;
      max-height: 360px;
      overflow-y: auto;
      border: 1px solid #000;
    }

    .copy-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: #333;
      color: #fff;
      border: 1px solid #444;
      cursor: pointer;
      width: 36px;
      height: 36px;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    .copy-btn:hover { background: #444; }

    .divider {
      border: none;
      border-top: 1px solid #e0e0e0;
      margin: 24px 0;
    }

    @media (max-width: 1024px) {
      .main-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

<div class="container">
  <header>
    <h1>Widget Code Generator</h1>
    <p class="subtitle">Upload your extension, add a widget, download updated extension</p>
    <nav class="tab-nav">
      <a href="sitecore-widget-editor-overview.html" class="tab-nav-link">Extension Overview</a>
      <a href="widget-code-generator.html" class="tab-nav-link active">Code Generator</a>
      <a href="widget-markup-specifications.html" class="tab-nav-link">Markup Specs</a>
    </nav>
  </header>

  <div class="main-grid">

    <!-- LEFT: Input -->
    <div class="panel">
      <div class="panel-title">1 â€” Upload Current Extension</div>

      <div class="upload-zone" id="uploadZone">
        <input type="file" id="zipInput" accept=".zip">
        <div class="upload-icon">ðŸ“¦</div>
        <div class="upload-label"><strong>Click to upload</strong> your extension .zip</div>
        <div class="upload-status" id="uploadStatus">No file selected</div>
      </div>

      <div id="currentWidgets" style="display:none;">
        <div class="analysis-title">Existing Widgets Found</div>
        <div class="widget-list" id="widgetList"></div>
      </div>

      <hr class="divider">

      <div class="panel-title">2 â€” New Widget Details</div>

      <div class="form-group">
        <label>Widget Class Name</label>
        <input type="text" id="widgetClass" placeholder="team-member-bio">
        <div class="info-box">CSS class on the widget's outer container</div>
      </div>

      <div class="form-group">
        <label>Widget Display Name</label>
        <input type="text" id="widgetName" placeholder="Team Member Bio">
      </div>

      <div class="form-group">
        <label>Widget Description</label>
        <input type="text" id="widgetDescription" placeholder="Edit team member bios">
      </div>

      <div class="form-group">
        <label>Widget HTML</label>
        <textarea id="htmlInput" placeholder="Paste widget HTML with dynamic-* classes..."></textarea>
        <div class="info-box">Use dynamic-object, dynamic-text, dynamic-number, dynamic-email, etc.</div>
      </div>

      <button onclick="generateCode()" id="generateBtn" disabled>Generate &amp; Download</button>

      <div id="statusOutput"></div>
    </div>

    <!-- RIGHT: Output -->
    <div class="panel">
      <div class="panel-title">Output</div>

      <div id="outputPlaceholder" style="color:#999; font-size:14px; padding: 20px 0;">
        Upload your extension ZIP to get started.
      </div>

      <div id="outputSection" style="display:none;">
        <button class="download-btn" id="downloadBtn">ðŸ“¦ Download Updated Extension (.zip)</button>
        <p class="download-info">Drop-in replacement â€” contains all existing widgets plus your new one</p>

        <hr class="divider">

        <div class="panel-title">Processed HTML Preview</div>
        <div class="code-wrapper">
          <button class="copy-btn" onclick="copyHTML()" title="Copy">ðŸ“‹</button>
          <pre id="htmlPreview">// Generate to see output</pre>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
  // â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let loadedZip = null;
  let currentContentScript = '';
  let currentSidepanel = '';
  let currentManifest = '';
  let detectedWidgets = [];
  let generatedZipBlob = null;

  // â”€â”€â”€ ZIP Upload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.getElementById('zipInput').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
      loadedZip = await JSZip.loadAsync(file);
      await readExtensionFiles();
    } catch (err) {
      setUploadStatus('error', `Failed to read ZIP: ${err.message}`);
    }
  });

  async function readExtensionFiles() {
    try {
      // Read content-script.js
      const csFile = loadedZip.file('content-script.js');
      if (!csFile) throw new Error('content-script.js not found in ZIP');
      currentContentScript = await csFile.async('string');

      // Read sidepanel.js
      const spFile = loadedZip.file('sidepanel.js');
      if (!spFile) throw new Error('sidepanel.js not found in ZIP');
      currentSidepanel = await spFile.async('string');

      // Read manifest.json
      const mfFile = loadedZip.file('manifest.json');
      if (mfFile) {
        currentManifest = await mfFile.async('string');
      }

      // Detect existing widgets from WIDGET_REGISTRY
      detectedWidgets = parseWidgetRegistry(currentContentScript);

      // Update UI
      setUploadStatus('loaded', `âœ“ Loaded â€” ${Object.keys(loadedZip.files).length} files found`);
      document.getElementById('uploadZone').classList.add('has-file');
      showExistingWidgets();
      document.getElementById('generateBtn').removeAttribute('disabled');

    } catch (err) {
      setUploadStatus('error', err.message);
    }
  }

  function parseWidgetRegistry(code) {
    const widgets = [];
    const registryMatch = code.match(/const WIDGET_REGISTRY\s*=\s*\{([\s\S]*?)\};/);
    if (!registryMatch) return widgets;

    const registryBody = registryMatch[1];
    const entryPattern = /'([^']+)'\s*:\s*\{\s*name\s*:\s*'([^']+)'/g;
    let match;
    while ((match = entryPattern.exec(registryBody)) !== null) {
      widgets.push({ className: match[1], name: match[2] });
    }
    return widgets;
  }

  function showExistingWidgets() {
    const container = document.getElementById('currentWidgets');
    const list = document.getElementById('widgetList');

    if (detectedWidgets.length === 0) {
      container.style.display = 'none';
      return;
    }

    list.innerHTML = detectedWidgets.map((w, idx) => `
      <div class="widget-item">
        <div class="widget-item-left">
          <span class="widget-item-name">${w.className}</span>
          <span class="widget-item-badge">${w.name}</span>
        </div>
        <button class="widget-item-delete" onclick="deleteWidget('${w.className}')">Delete</button>
      </div>
    `).join('');

    container.style.display = 'block';
  }

  async function deleteWidget(widgetClass) {
    if (!confirm(`Delete widget "${widgetClass}"?\n\nThis will remove it from the extension code.`)) {
      return;
    }

    try {
      // Remove from content-script.js
      currentContentScript = removeWidgetFromContentScript(currentContentScript, widgetClass);
      
      // Remove from sidepanel.js
      currentSidepanel = removeWidgetFromSidepanel(currentSidepanel, widgetClass);

      // Update detected widgets list
      detectedWidgets = detectedWidgets.filter(w => w.className !== widgetClass);

      // Create updated ZIP and UPDATE loadedZip state (no download yet)
      const newZip = new JSZip();
      const filePromises = [];
      loadedZip.forEach((relativePath, file) => {
        filePromises.push(
          file.async('uint8array').then(content => {
            newZip.file(relativePath, content);
          })
        );
      });
      await Promise.all(filePromises);

      // Overwrite with updated files
      newZip.file('content-script.js', currentContentScript);
      newZip.file('sidepanel.js', currentSidepanel);
      if (currentManifest) {
        const updatedManifest = updateManifest(currentManifest);
        newZip.file('manifest.json', updatedManifest);
        currentManifest = updatedManifest;
      }

      // CRITICAL: Update loadedZip to the new ZIP so next operations use updated state
      loadedZip = newZip;

      // Update UI
      showExistingWidgets();
      showStatus('success', `âœ“ Widget "${widgetClass}" removed. Click "Generate & Download" to get your updated extension.`);

    } catch (err) {
      showStatus('error', `Failed to delete widget: ${err.message}`);
    }
  }

  function removeWidgetFromContentScript(code, widgetClass) {
    // Remove from WIDGET_REGISTRY
    const registryPattern = new RegExp(`\\s*,?\\s*'${widgetClass}'\\s*:\\s*\\{[^}]*\\}`, 'g');
    code = code.replace(registryPattern, '');

    // Remove router case from getWidgetData
    const getPattern = new RegExp(`\\s*if \\(widgetClass === '${widgetClass}'\\) \\{[^}]*\\}\\s*`, 'g');
    code = code.replace(getPattern, '');

    // Remove router case from updateWidgetData
    const updatePattern = new RegExp(`\\s*if \\(widgetClass === '${widgetClass}'\\) \\{[^}]*\\}\\s*`, 'g');
    code = code.replace(updatePattern, '');

    // Remove widget functions section
    const camelClass = toCamelCase(widgetClass);
    const functionName = camelClass.charAt(0).toUpperCase() + camelClass.slice(1);
    const sectionPattern = new RegExp(
      `// =+\\s*\\n// ${widgetClass.toUpperCase().replace(/-/g, ' ')}\\s*\\n// =+[\\s\\S]*?(?=\\n// =|\\n\\n$|$)`,
      'g'
    );
    code = code.replace(sectionPattern, '');

    return code;
  }

  function removeWidgetFromSidepanel(code, widgetClass) {
    // Remove from renderEditor router
    const camelClass = toCamelCase(widgetClass);
    const functionName = camelClass.charAt(0).toUpperCase() + camelClass.slice(1);
    const renderPattern = new RegExp(
      `\\s*if \\(widgetClass === '${widgetClass}'\\) \\{[^}]*\\}\\s*`,
      'g'
    );
    code = code.replace(renderPattern, '');

    // Remove editor functions section
    const sectionPattern = new RegExp(
      `// =+\\s*\\n// ${widgetClass.toUpperCase().replace(/-/g, ' ')} EDITOR\\s*\\n// =+[\\s\\S]*?(?=\\n// =|$)`,
      'g'
    );
    code = code.replace(sectionPattern, '');

    return code;
  }

  function setUploadStatus(type, message) {
    const el = document.getElementById('uploadStatus');
    el.textContent = message;
    el.className = `upload-status ${type}`;
  }

  // â”€â”€â”€ HTML Processing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function getDirectText(el) {
    let text = '';
    el.childNodes.forEach(node => {
      if (node.nodeType === 3) {
        text += node.textContent.trim();
      }
    });
    return text;
  }

  function processHTML(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const widgetContainer = doc.body.firstElementChild;
    if (!widgetContainer) return null;

    const dynamicObjects = widgetContainer.querySelectorAll('.dynamic-object');
    const hasDynamicObjects = dynamicObjects.length > 0;

    function processElement(el, target) {
      // target = the element to add data attributes to (either the el itself)
      const fieldCounts = {};

      const allEls = el.querySelectorAll('*');
      const dynamicEls = [];

      allEls.forEach(child => {
        const hasDynClass = Array.from(child.classList).some(cls =>
          cls.startsWith('dynamic-') && cls !== 'dynamic-object'
        );
        if (hasDynClass) dynamicEls.push(child);
      });

      dynamicEls.forEach(child => {
        Array.from(child.classList).forEach(cls => {
          if (cls.startsWith('dynamic-') && cls !== 'dynamic-object') {
            const type = cls.replace('dynamic-', '');
            fieldCounts[type] = (fieldCounts[type] || 0) + 1;
            const fieldNum = fieldCounts[type];

            // Extract direct text only (ignores child elements like <span>%)
            const directText = getDirectText(child);
            const dataValue = directText !== '' ? directText : (type === 'number' ? '0' : 'placeholder');

            // Data attribute goes ON the element itself
            child.setAttribute(`data-${type}-${fieldNum}`, dataValue);

            // Replace dynamic class with numbered class
            child.classList.remove(cls);
            child.classList.add(`${type}-${fieldNum}`);
          }
        });
      });
    }

    if (hasDynamicObjects) {
      dynamicObjects.forEach((obj, i) => {
        processElement(obj);
        obj.setAttribute('data-object-id', (i + 1).toString());
        obj.classList.remove('dynamic-object');
      });
    } else {
      processElement(widgetContainer);
    }

    return doc.body.innerHTML;
  }

  function analyzeHTML(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const container = doc.body.firstElementChild;
    if (!container) return { error: 'No widget container found' };

    const widgetClass = container.className.split(' ')[0];
    const dynamicObjects = container.querySelectorAll('.dynamic-object');
    const hasDynamicObjects = dynamicObjects.length > 0;
    const allDynamic = container.querySelectorAll('[class*="dynamic-"]');

    if (allDynamic.length === 0) return { error: 'No dynamic-* classes found' };

    const fieldTypes = new Set();
    allDynamic.forEach(el => {
      Array.from(el.classList).forEach(cls => {
        if (cls.startsWith('dynamic-') && cls !== 'dynamic-object') {
          fieldTypes.add(cls.replace('dynamic-', ''));
        }
      });
    });

    return {
      widgetClass,
      hasDynamicObjects,
      objectCount: hasDynamicObjects ? dynamicObjects.length : 1,
      fieldTypes: Array.from(fieldTypes)
    };
  }

  // â”€â”€â”€ Code Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function toCamelCase(str) {
    return str.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
  }

  function toDisplayName(str) {
    return str.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
  }

  function injectIntoContentScript(code, widgetClass, widgetName, widgetDescription, hasObjects, functionName) {
    // 1. Add to WIDGET_REGISTRY
    const registryEntry = `  '${widgetClass}': {\n    name: '${widgetName}',\n    description: '${widgetDescription}'\n  }`;
    code = code.replace(
      /(\s*\/\/\s*Add more widgets here\s*\n?\s*\};)/,
      `,\n${registryEntry}\n  // Add more widgets here\n};`
    );

    // 2. Add to getWidgetData router
    const getDataCase = `  if (widgetClass === '${widgetClass}') {\n    return get${functionName}Data();\n  }`;
    code = code.replace(
      /(\/\/\s*Add more widget data extractors here\s*\n\s*return null;)/,
      `${getDataCase}\n  // Add more widget data extractors here\n  return null;`
    );

    // 3. Add to updateWidgetData router
    const updateDataCase = `  if (widgetClass === '${widgetClass}') {\n    success = update${functionName}Data(data);\n  }`;
    code = code.replace(
      /(\/\/\s*Add more widget updaters here)/,
      `${updateDataCase}\n  // Add more widget updaters here`
    );

    // 4. Append widget functions at end of file
    const newFunctions = generateWidgetFunctions(widgetClass, hasObjects, functionName);
    code = code.trimEnd() + '\n\n' + newFunctions;

    return code;
  }

  function generateWidgetFunctions(widgetClass, hasObjects, functionName) {
    const getDataFn = hasObjects ? `
function get${functionName}Data() {
  const widget = findWidgetElement('${widgetClass}');
  if (!widget) return null;

  const objects = [];
  widget.querySelectorAll('[data-object-id]').forEach(el => {
    const obj = { id: el.dataset.objectId || '' };
    el.querySelectorAll('*').forEach(child => {
      Array.from(child.attributes).forEach(attr => {
        if (attr.name.startsWith('data-') && attr.name !== 'data-object-id') {
          obj[attr.name.replace('data-', '').replace(/-/g, '_')] = attr.value;
        }
      });
    });
    objects.push(obj);
  });

  return { objects };
}` : `
function get${functionName}Data() {
  const widget = findWidgetElement('${widgetClass}');
  if (!widget) return null;

  const data = {};
  widget.querySelectorAll('*').forEach(el => {
    Array.from(el.attributes).forEach(attr => {
      if (attr.name.startsWith('data-')) {
        data[attr.name.replace('data-', '').replace(/-/g, '_')] = attr.value;
      }
    });
  });

  return data;
}`;

    const updateDataFn = hasObjects ? `
function update${functionName}Data(data) {
  const widget = findWidgetElement('${widgetClass}');
  if (!widget) return false;

  const objectEls = widget.querySelectorAll('[data-object-id]');
  data.objects.forEach((obj, i) => {
    if (!objectEls[i]) return;
    Object.keys(obj).forEach(key => {
      if (key === 'id') return;
      const attrName = 'data-' + key.replace(/_/g, '-');
      const targetEl = objectEls[i].querySelector('[' + attrName + ']');
      if (targetEl) {
        targetEl.setAttribute(attrName, obj[key]);
        targetEl.textContent = obj[key];
      }
    });
  });

  return true;
}` : `
function update${functionName}Data(data) {
  const widget = findWidgetElement('${widgetClass}');
  if (!widget) return false;

  Object.keys(data).forEach(key => {
    const attrName = 'data-' + key.replace(/_/g, '-');
    const targetEl = widget.querySelector('[' + attrName + ']');
    if (targetEl) {
      targetEl.setAttribute(attrName, data[key]);
      targetEl.textContent = data[key];
    }
  });

  return true;
}`;

    return `// =============================================================================
// ${widgetClass.toUpperCase().replace(/-/g, ' ')}
// =============================================================================
${getDataFn}
${updateDataFn}
`;
  }

  function injectIntoSidepanel(code, widgetClass, widgetName, hasObjects, functionName) {
    // 1. Add to renderEditor router
    const renderCase = `\n  if (widgetClass === '${widgetClass}') {\n    container.innerHTML = render${functionName}Editor(data);\n    attach${functionName}EditorEvents(data);\n  }\n`;
    code = code.replace(
      /(container\.style\.display\s*=\s*'block';\s*\n?\s*\})/,
      `${renderCase}\n  container.style.display = 'block';\n}`
    );

    // 2. Append editor functions before HELPERS section
    const editorFunctions = generateEditorFunctions(widgetClass, widgetName, hasObjects, functionName);
    code = code.replace(
      /(\/\/ =+\s*\n\/\/ HELPERS)/,
      `${editorFunctions}\n// =============================================================================\n// HELPERS`
    );

    return code;
  }

  function generateEditorFunctions(widgetClass, widgetName, hasObjects, functionName) {
    const inputTypeMap = { text: 'text', email: 'email', number: 'text', phone: 'tel', url: 'url', date: 'date', textarea: 'textarea', checkbox: 'checkbox' };

    const renderFn = hasObjects ? `
function render${functionName}Editor(data) {
  const objects = data.objects;
  const inputTypes = ${JSON.stringify(inputTypeMap)};

  return \`
    <div class="editor-title">${widgetName}</div>
    \${objects.map((obj, index) => \`
      <div class="plan-section">
        <div class="plan-section-title">Item \${index + 1}</div>
        \${Object.keys(obj).filter(k => k !== 'id').map(key => {
          const fieldType = key.split('_')[0];
          const inputType = inputTypes[fieldType] || 'text';
          const label = key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());
          if (inputType === 'textarea') {
            return \`<div class="form-group"><label>\${label}</label><textarea class="field-\${key}" data-object-index="\${index}" rows="3">\${obj[key]}</textarea></div>\`;
          } else if (inputType === 'checkbox') {
            return \`<div class="form-group"><label><input type="checkbox" class="field-\${key}" data-object-index="\${index}" \${obj[key] === 'true' ? 'checked' : ''}> \${label}</label></div>\`;
          } else {
            return \`<div class="form-group"><label>\${label}</label><input type="\${inputType}" class="field-\${key}" data-object-index="\${index}" value="\${obj[key]}"></div>\`;
          }
        }).join('')}
      </div>
    \`).join('')}
    <div class="button-group">
      <button class="btn-secondary" id="clearBtn">Reset</button>
      <button class="btn-primary" id="saveBtn">Apply Changes</button>
    </div>
  \`;
}` : `
function render${functionName}Editor(data) {
  const inputTypes = ${JSON.stringify(inputTypeMap)};

  return \`
    <div class="editor-title">${widgetName}</div>
    <div class="plan-section">
      \${Object.keys(data).map(key => {
        const fieldType = key.split('_')[0];
        const inputType = inputTypes[fieldType] || 'text';
        const label = key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());
        if (inputType === 'textarea') {
          return \`<div class="form-group"><label>\${label}</label><textarea class="field-\${key}" rows="3">\${data[key]}</textarea></div>\`;
        } else if (inputType === 'checkbox') {
          return \`<div class="form-group"><label><input type="checkbox" class="field-\${key}" \${data[key] === 'true' ? 'checked' : ''}> \${label}</label></div>\`;
        } else {
          return \`<div class="form-group"><label>\${label}</label><input type="\${inputType}" class="field-\${key}" value="\${data[key]}"></div>\`;
        }
      }).join('')}
    </div>
    <div class="button-group">
      <button class="btn-secondary" id="clearBtn">Reset</button>
      <button class="btn-primary" id="saveBtn">Apply Changes</button>
    </div>
  \`;
}`;

    const attachFn = `
function attach${functionName}EditorEvents(originalData) {
  document.getElementById('saveBtn').addEventListener('click', save${functionName}Data);
  document.getElementById('clearBtn').addEventListener('click', () => {
    renderEditor('${widgetClass}', originalData);
  });
}`;

    const saveFn = hasObjects ? `
async function save${functionName}Data() {
  const formData = { objects: [] };
  const count = document.querySelectorAll('.plan-section').length;
  for (let i = 0; i < count; i++) {
    const obj = { id: (i + 1).toString() };
    document.querySelectorAll(\`[data-object-index="\${i}"]\`).forEach(input => {
      const key = input.className.split(' ').find(c => c.startsWith('field-'))?.replace('field-', '');
      if (key) obj[key] = input.type === 'checkbox' ? input.checked.toString() : input.value;
    });
    formData.objects.push(obj);
  }
  await sendWidgetUpdate('${widgetClass}', formData);
}` : `
async function save${functionName}Data() {
  const formData = {};
  document.querySelectorAll('[class*="field-"]').forEach(input => {
    const key = input.className.split(' ').find(c => c.startsWith('field-'))?.replace('field-', '');
    if (key) formData[key] = input.type === 'checkbox' ? input.checked.toString() : input.value;
  });
  await sendWidgetUpdate('${widgetClass}', formData);
}`;

    return `
// =============================================================================
// ${widgetClass.toUpperCase().replace(/-/g, ' ')} EDITOR
// =============================================================================
${renderFn}
${attachFn}
${saveFn}
`;
  }

  function updateManifest(manifestJson) {
    try {
      const manifest = JSON.parse(manifestJson);
      const parts = (manifest.version || '1.0.0').split('.');
      parts[2] = (parseInt(parts[2] || 0) + 1).toString();
      manifest.version = parts.join('.');
      return JSON.stringify(manifest, null, 2);
    } catch {
      return manifestJson;
    }
  }

  // â”€â”€â”€ Main Generate Function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function generateCode() {
    const widgetClass = document.getElementById('widgetClass').value.trim();
    const widgetName = document.getElementById('widgetName').value.trim();
    const widgetDescription = document.getElementById('widgetDescription').value.trim();
    const htmlInput = document.getElementById('htmlInput').value.trim();
    const statusEl = document.getElementById('statusOutput');

    statusEl.innerHTML = '';

    if (!loadedZip) return showStatus('error', 'Please upload your extension ZIP first');

    // If no HTML provided, just package current state (e.g., after deletions)
    if (!htmlInput) {
      try {
        generatedZipBlob = await loadedZip.generateAsync({ type: 'blob' });

        document.getElementById('downloadBtn').onclick = () => {
          const link = document.createElement('a');
          link.href = URL.createObjectURL(generatedZipBlob);
          link.download = `sitecore-widget-editor-updated.zip`;
          link.click();
        };

        document.getElementById('outputPlaceholder').style.display = 'none';
        document.getElementById('outputSection').style.display = 'block';
        document.getElementById('htmlPreview').textContent = '// No new widget HTML to preview';

        showStatus('success', `âœ“ Extension packaged with ${detectedWidgets.length} widget(s). Ready to download.`);
        return;
      } catch (err) {
        return showStatus('error', `Failed to package extension: ${err.message}`);
      }
    }

    // Adding a new widget - require all fields
    if (!widgetClass) return showStatus('error', 'Please enter a widget class name');
    
    // Use defaults if not provided
    const finalWidgetName = widgetName || toDisplayName(widgetClass);
    const finalWidgetDescription = widgetDescription || `Edit ${widgetClass.replace(/-/g, ' ')} data`;

    // Check for duplicate
    const existingWidget = detectedWidgets.find(w => w.className === widgetClass);
    if (existingWidget) {
      const replace = confirm(
        `Widget "${widgetClass}" already exists.\n\nDo you want to REPLACE it with the new version?\n\nClick OK to replace, Cancel to abort.`
      );
      
      if (!replace) {
        return showStatus('error', 'Generation cancelled');
      }

      // Remove the existing widget before adding new one
      currentContentScript = removeWidgetFromContentScript(currentContentScript, widgetClass);
      currentSidepanel = removeWidgetFromSidepanel(currentSidepanel, widgetClass);
      detectedWidgets = detectedWidgets.filter(w => w.className !== widgetClass);
    }

    const analysis = analyzeHTML(htmlInput);
    if (analysis.error) return showStatus('error', analysis.error);

    const camelClass = toCamelCase(widgetClass);
    const functionName = camelClass.charAt(0).toUpperCase() + camelClass.slice(1);
    const hasObjects = analysis.hasDynamicObjects;

    // Process HTML
    const processedHTML = processHTML(htmlInput);
    document.getElementById('htmlPreview').textContent = processedHTML;

    // Inject into existing files
    const newContentScript = injectIntoContentScript(
      currentContentScript, widgetClass, finalWidgetName, finalWidgetDescription, hasObjects, functionName
    );
    const newSidepanel = injectIntoSidepanel(
      currentSidepanel, widgetClass, finalWidgetName, hasObjects, functionName
    );
    const newManifest = currentManifest ? updateManifest(currentManifest) : null;

    // Also add a sendWidgetUpdate helper if not already present
    let finalSidepanel = newSidepanel;
    if (!finalSidepanel.includes('async function sendWidgetUpdate')) {
      finalSidepanel += `

async function sendWidgetUpdate(widgetClass, data) {
  const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
  chrome.tabs.sendMessage(tab.id, {
    action: 'updateWidgetData',
    widgetClass,
    data
  }, (response) => {
    if (response && response.success) {
      showSuccess('Changes applied successfully!');
    } else {
      showError('Failed to apply changes. Please try again.');
    }
  });
}`;
    }

    // Build new ZIP from existing ZIP + updated files
    const newZip = new JSZip();

    // Copy all existing files
    const filePromises = [];
    loadedZip.forEach((relativePath, file) => {
      filePromises.push(
        file.async('uint8array').then(content => {
          newZip.file(relativePath, content);
        })
      );
    });
    await Promise.all(filePromises);

    // Overwrite updated files
    newZip.file('content-script.js', newContentScript);
    newZip.file('sidepanel.js', finalSidepanel);
    if (newManifest) newZip.file('manifest.json', newManifest);
    newZip.file('processed-widget.html', processedHTML);

    // Generate blob
    generatedZipBlob = await newZip.generateAsync({ type: 'blob' });

    // Setup download
    document.getElementById('downloadBtn').onclick = () => {
      const link = document.createElement('a');
      link.href = URL.createObjectURL(generatedZipBlob);
      link.download = `sitecore-widget-editor-${widgetClass}.zip`;
      link.click();
    };

    // Show output
    document.getElementById('outputPlaceholder').style.display = 'none';
    document.getElementById('outputSection').style.display = 'block';

    showStatus('success', `âœ“ Ready â€” "${finalWidgetName}" added. ${detectedWidgets.length + 1} widgets total in updated extension.`);
  }

  function showStatus(type, message) {
    document.getElementById('statusOutput').innerHTML = `<div class="${type}-msg">${message}</div>`;
  }

  function copyHTML() {
    const code = document.getElementById('htmlPreview').textContent;
    navigator.clipboard.writeText(code).then(() => {
      const btn = event.target;
      const orig = btn.textContent;
      btn.textContent = 'âœ“';
      setTimeout(() => btn.textContent = orig, 2000);
    });
  }
</script>

</body>
</html>